#!/usr/bin/env pnpython2

#
#   Rawmeet deployment (.dep) file handler
#
#   Conforms to rawmeet dep file spec 0007.121 (Bob Greschke)
#

import sys, string, re, time, copy, math
import TimeDoy, columns

PROG_VERSION = '2012.131.1'

#numericRE = re.compile ("[+-]*[0-9]*\.+?[0-9]*")
latlonRE = re.compile ("..lat$|..lon$")

#
#   Match SHOT into Event_t
#
Match_Event_t = { 'S_id':'id_s',
                  'S_station':'location/description_s',
                  'S_lat':'location/Y/value_d',
                  'S_lat_units':'location/Y/units_s',
                  'S_lon':'location/X/value_d',
                  'S_lon_units':'location/X/units_s',
                  'S_elev':'location/Z/value_d',
                  'S_elev_units':'location/Z/units_s',
                  'S_coordinate_system':'location/coordinate_system_s',
                  'S_projection':'location/projection_s',
                  'S_ellipsoid':'location/ellipsoid_s',
                  'S_epoch':'time/epoch_l',
                  'S_ascii':'time/ascii_s',
                  'S_ms':'time/micro_seconds_i',
                  'S_type':'time/type_s',
                  'S_depth':'depth/value_d',
                  'S_depth_units':'depth/units_s',
                  'S_size':'size/value_d',
                  'S_size_units':'size/units_s',
                  'S_comment':'description_s' }

#Match_Receiver_t = { 'R_lat':'location/X/value_d',
                     #'R_lat_units':'location/X/units_s',
                     #'R_lon':'location/Y/value_d',
                     #'R_lon_units':'location/Y/units_s',
                     #'R_elev':'location/Z/value_d',
                     #'R_elev_units':'location/Z/units_s',
                     #'R_sensor':'sensor/serial_number_s',
                     #'R_deploy-epoch':'deploy_time/epoch_l',
                     #'R_deploy-ascii':'deploy_time/ascii_s',
                     #'R_deploy-ms':'deploy_time/micro_seconds_i',
                     #'R_typed':'deploy_time/type_e',
                     #'R_pickup-epoch':'pickup_time/epoch_l',
                     #'R_pickup-ascii':'pickup_time/ascii_s',
                     #'R_pickup-ms':'pickup_time/micro_seconds_i',
                     #'R_typep':'pickup_time/type_e'}

#   Match RECV Array_t_[nnn] so we have a starting point
Match_Sort_t = { 'R_array':'array_name_s' }

#
#   Match RECV to Array_t
#
Match_Array_t = { 'R_id':'das/serial_number_s',
                  'R_receiver-type':'das/model_s',
                  'R_station':'id_s',
                  'R_comment':'description_s',
                  'R_lat':'location/Y/value_d',
                  'R_lat_units':'location/Y/units_s',
                  'R_lon':'location/X/value_d',
                  'R_lon_units':'location/X/units_s',
                  'R_elev':'location/Z/value_d',
                  'R_elev_units':'location/Z/units_s',
                  'R_sensor':'sensor/serial_number_s',
                  'R_deploy-epoch':'deploy_time/epoch_l',
                  'R_deploy-ascii':'deploy_time/ascii_s',
                  'R_deploy-ms':'deploy_time/micro_seconds_i',
                  'R_typed':'deploy_time/type_s',
                  'R_pickup-epoch':'pickup_time/epoch_l',
                  'R_pickup-ascii':'pickup_time/ascii_s',
                  'R_pickup-ms':'pickup_time/micro_seconds_i',
                  'R_typep':'pickup_time/type_s',
                  'R_chan':'channel_number_i' }

#
#   Match TIME to Time_t
#
Match_Time_t = { 'T_file':'description_s',
                 'T_drift':'slope_d',
                 'T_diff':'offset_l',
                 'T_start-epoch':'start_time/epoch_l',
                 'T_start-ascii':'start_time/ascii_s',
                 'T_start-type':'start_time/type_s',
                 'T_start-ms':'start_time/micro_seconds_i',
                 'T_end-epoch':'end_time/epoch_l',
                 'T_end-ascii':'end_time/ascii_s',
                 'T_end-type':'end_time/type_s',
                 'T_end-ms':'end_time/micro_seconds_i' }

class Field :
    '''   Dep file fields with quality and comment   '''
    __slots__ = 'value', 'quality', 'comment'
    def __init__ (self, value, quality = '+', comment = None) :
        self.value = value
        #   Quality == '+' -> good
        #   Quality == '?' -> questionable
        #   Quality == '-' -> bad
        self.quality = quality
        self.comment = comment

class Dep :
    RECVorder = ('R_id', 'R_station', 'R_line','R_receiver-type', 'R_chan',
                 'R_sensor', 'R_uphole', 'R_lat', 'R_lon', 'R_elev', 'R_team',
                 'R_deploy-epoch', 'R_pickup-epoch', 'R_shots', 'R_comment')

    SHOTorder = ('S_id', 'S_station', 'S_line', 'S_lat', 'S_lon', 'S_elev',
                 'S_epoch', 'S_pre-trig', 'S_post-trig', 'S_sr', 'S_depth',
                 'S_size', 'S_rvel', 'S_radius', 'S_comment')
    
    def __init__ (self, filename) :
        self.filename = filename
        self.fh = None
        self.ps = []                        #   Parsed shot array
        self.pr = []                        #   Parsed receiver array
        self.pt = []                        #   Parsed time array
        self.currents = []                  #   Current shots
        self.currentr = []                  #   Current receivers
        self.currentt = []                  #   Current time array
        
    def open (self) :
        #   Read from STDIN or a file
        try :
            if self.filename == '-' :
                self.fh = sys.stdin
            else :
                self.fh = file (self.filename)
        except Exception as e :
            sys.stderr.write ("Error: Failed to open %s. Exception: %s\n" % (self.filename, e))
            self.fh = None
            
    def close (self) :
        self.fh.close ()
        
    def epoch (self, yr, doy, hr, mn, sc) :
        tm = TimeDoy.TimeDoy ()
        mo, da = tm.getMonthDay (int (yr), int (doy))
        try :
            sc = string.split (sc, '.')[0]
        except AttributeError :
            sc = sc
            
        e = time.mktime ((int (yr), mo, da, int (hr), int (mn), int (sc), -1, int (doy), -1))
        
        return int (e)
    
    def human (self, e, ms = 0) :
        ttuple = time.gmtime (int (e))
        
        h = "%04d:%03d:%02d:%02d:%02d.%03d" % (ttuple[0],
                                               ttuple[7],
                                               ttuple[3],
                                               ttuple[4],
                                               ttuple[5],
                                               int (ms))
                                               
        return h
    
    def _sign (self, latlon) :
        ret = latlon
        try :
            nsew = str (latlon[0])
            nsew.upper ()
            if nsew == 'N' or nsew == 'E' :
                ret = '+' + latlon[1:]
            elif nsew == 'S' or nsew == 'W' :
                ret = '-' + latlon[1:]
        except IndexError as e :
            pass
        
        return ret
    
    def _unsign (self, val, latlon) :
        ret = val
        #print latlon
        try :
            nsew = str (val[0])
            nsew.upper ()
            if nsew == 'N' or nsew == 'S' or nsew == 'E' or nsew == 'W' :
                return ret
            
            if nsew == '+' :
                val = val[1:]
                
            if latlon == 'lat' :
                if nsew == '-' :
                    ret = 'S' + val[1:]
                else :
                    ret = 'N' + val
            elif latlon == 'lon' :
                if nsew == '-' :
                    ret = 'W' + val[1:]
                else :
                    ret = 'E' + val
                
        except IndexError as e :
            pass
        
        return ret
    
    def saneSHOT (self) :
        '''   Are the values in the SHOT lines of dep file sane?   '''
        #   The order in of the values in the dep file
        order = ('S_id', 'S_station', 'S_line', 'S_lat', 'S_lon', 'S_elev',
                 'S_epoch', 'S_pre-trig', 'S_post-trig', 'S_sr', 'S_depth',
                 'S_size', 'S_rvel', 'S_radius', 'S_comment')
        
        self.rewindShot ()
        #   The entire file in order
        bfile = []
        while 1 :
            p = self.nextShot ()
            if not p : break
            #   The line in proper order
            bline = []
            for k in order :
                #   str (None) returns 'None'
                val = None
                if p[k] != None and p[k] != '' :
                    val = str (p[k])
                    
                qual = '+'
                comm = ''
                if k == 'S_id' :
                    #   The shot ID should exist
                    if val == None :
                        val = ' '
                        qual = '-'
                        comm = 'Shot ID must not be empty.'
                    #   We expect numeric shot IDs
                    elif not isNumeric (val) :
                        qual = '-'
                        comm = 'Shot ID should be a numeric value.'
                elif k == 'S_station' :
                    if val == None :
                        val = ' '
                        qual = '?'
                        comm = 'Station?'
                elif k == 'S_line' :
                    if val == None :
                        val = ' '
                        qual = '?'
                        comm = 'No array/line given.'
                    elif not isNumeric (val) :
                        qual = '?'
                        comm = 'It is recommended that lines have a numeric value.'
                elif k == 'S_lat' :
                    if val == None :
                        val = ' '
                        qual = '?'
                        comm = 'No latitude given for this station?'
                    else :
                        if float (val) < -90 or float (val) > 90 :
                            qual = '-'
                            comm = 'Latitudes are expected to be in the S90 to N90 range.'
                        if float (val) == 0. :
                            qual = '?'
                            comm = 'Questionable lat of 0'
                        if float (val) < 0 :
                            val = val.replace ('-', 'S')
                        else :
                            if val[0] == '+' :
                                val = val.replace ('+', 'N')
                            else :
                                val = 'N' + val
                elif k == 'S_lon' :
                    if val == None :
                        val = ' '
                        qual = '?'
                        comm = 'No longitude given for this station?'
                    else :
                        if float (val) < -180 or float (val) > 180 :
                            qual = '-'
                            comm = 'Longitudes are expected to be in the range W180 to E180.'
                        if float (val) == 0. :
                            qual = '?'
                            comm = 'Questionable lon of 0'
                        if float (val) < 0 :
                            val = val.replace ('-', 'W')
                        else :
                            if val[0] == '+' :
                                val = val.replace ('+', 'E')
                            else :
                                val = 'E' + val
                elif k == 'S_elev' :
                    if val == None :
                        val = ' '
                        qual = '?'
                        comm = 'No elevation given for shot?'
                    else :
                        #   Expect elevation to be numeric and below Mt Everest
                        #   and above the Dead Sea
                        if not isNumeric (val) :
                            qual = '-'
                            comm = 'Elevation value should be numeric.'
                        elif float (val) < -418. or float (val) > 8848. :
                            qual = '?'
                            comm = 'Elevations normally fall in the range of 418 meters below sealevel to 8848 meters above sealevel.'
                elif k == 'S_epoch' :
                    now = time.time ()
                    if val == None :
                        val = ' '
                        qual = '?'
                        comm = 'No shot time given.'
                    else :
                        if not isNumeric (val) :
                            qual = '-'
                            comm = 'Epoch time should be numeric.'
                        elif float (val) < 0. or float (val) > now :
                            qual = '?'
                            comm = 'Shot time appears to be before 1970 or in the future.'
                        #   Put it back in yyyy:jjj:hh:mm:ss.sss format
                        val = self.human (val, p['S_ms'])
                elif k == 'S_pre-trig' :
                    if val != None :
                        if not isNumeric (val) :
                            qual = '-'
                            comm = 'Pre-trigger value should be numeric.'
                    else :
                        val = ' '
                elif k == 'S_post-trig' :
                    if val != None :
                        if not isNumeric (val) :
                            qual = '-'
                            comm = 'Post-trigger value should be numeric.'
                    else :
                        val = ' '
                elif k == 'S_sr' :
                    if val != None :
                        if not isNumeric (val) :
                            qual = '-'
                            comm = 'Sample rate should be numeric.'
                        elif float (val) < 0. or float (val) > 1000. :
                            qual = '?'
                            comm = 'Questionable value for sample rate.'
                    else :
                        val = ' '
                elif k == 'S_depth' :
                    if val != None :
                        if not isNumeric (val) :
                            qual = '?'
                            comm = 'Shot depth should be numeric.'
                    else :
                        val = ' '
                elif k == 'S_size' :
                    if val != None :
                        if not isNumeric (val) :
                            qual = '?'
                            comm = 'Shot size in kg should be numeric.'
                    else :
                        val = ' '
                elif k == 'S_rvel' :
                    if val != None :
                        if not isNumeric (val) :
                            qual = '?'
                            comm = 'Reduction velocity should be numeric.'
                    else :
                        val = ' '
                elif k == 'S_radius' :
                    if val != None :
                        if not isNumeric (val) :
                            qual = '?'
                            comm = 'Radius should be numeric.'
                    else :
                        val = ' '
                elif k == 'S_comment' :
                    pass
                
                bline.append (Field (val, quality = qual, comment = comm))
                
            bfile.append (bline)
            
        return bfile
        
    def parseSHOT (self, line) :
        '''   Set blank non-existant fields to None, '', or 0   '''
        p = {}
        flds = string.split (line, ';')
        p['what'] = 'SHOT'
        try :
            p['S_id'] = str (int (string.strip (flds[1])))      #   Shot ID
        except (IndexError, ValueError) as e :
            p['S_id'] = None
        try :
            p['S_station'] = str (int (string.strip (flds[2]))) #   Station name
        except (IndexError, ValueError) as e :
            p['S_station'] = None
        try :
            p['S_line'] = string.strip (flds[3])               #   Member of array line
        except IndexError :
            p['S_line'] = None
        #   XXX   Need to pre-assign units_s   XXX
        p['S_coordinate_system'] = 'geodetic'
        p['S_projection'] = 'none'
        p['S_ellipsoid'] = 'wgs84'
        try :
            p['S_lat'] = self._sign (string.strip (flds[4]))    #   Latitude
        except IndexError :
            p['S_lat'] = None
        p['S_lat_units'] = 'degrees'
        try :
            p['S_lon'] = self._sign (string.strip (flds[5]))    #   Longitude
        except IndexError :
            p['S_lon'] = None
        p['S_lon_units'] = 'degrees'
        try :
            p['S_elev'] = string.strip (flds[6])                #   Elevation
        except IndexError :
            p['S_elev'] = None
        p['S_elev_units'] = 'meters'
        try :
            yr, doy, hr, mn, sc = string.split (string.strip (flds[7]), ':') #   
        except (ValueError, IndexError) as e :
            yr = doy = hr = mn = sc = 0
            
        p['S_epoch'] = self.epoch (yr, doy, hr, mn, sc)         #   Time of the shot
        #p['ascii'] = time.strftime ("%a %b %H:%M:%S %Y", p['epoch'])
        p['S_ascii'] = time.ctime (p['S_epoch']) #   Time of the shot
        #   This is actually micro-seconds
        ms = int (math.modf (float (sc))[0] * 1000000.)
        p['S_ms'] = ms
        p['S_type'] = 'BOTH'
        try :
            p['S_pre-trig'] = string.strip (flds[8])            #   Pre-trigger length in seconds
        except IndexError :
            p['S_pre-trig'] = None
        try :
            p['S_post-trig'] = string.strip (flds[9])           #   Post-trigger length in seconds
        except IndexError :
            p['S_post-trig'] = None
        try :
            p['S_sr'] = string.strip (flds[10])                 #   Sample rate
        except IndexError :
            p['S_sr'] = None
        try :
            p['S_depth'] = string.strip (flds[11])              #   Shot depth
        except IndexError :
            p['S_depth'] = None
        p['S_depth_units'] = 'meters'
        try :
            p['S_size'] = string.strip (flds[12])               #   Shot size (weight)
        except IndexError :
            p['S_size'] = None
        p['S_size_units'] = 'kilograms'
        try :
            p['S_rvel'] = string.strip (flds[13])               #   Reduction velocity
        except IndexError :
            p['S_rvel'] = None
        try :
            p['S_radius'] = string.strip (flds[14])             #   Radius of sensors to include
        except IndexError :
            p['S_radius'] = None
        try :
            p['S_comment'] = string.strip (flds[15])            #   Comments
        except IndexError :
            p['S_comment'] = ""
            
        return p
    
    def saneRECV (self) :
        #   Order of fields in dep file
        order = ('R_id', 'R_station', 'R_line','R_receiver-type', 'R_chan',
                 'R_sensor', 'R_uphole', 'R_lat', 'R_lon', 'R_elev', 'R_team',
                 'R_deploy-epoch', 'R_pickup-epoch', 'R_shots', 'R_comment')
        
        self.rewindReceiver ()
        bfile = []
        while 1 :
            p = self.nextReceiver ()
            if not p : break
            bline = []
            for k in order :
                val = None
                if p[k] != None and p[k] != '' :
                    val = str (p[k])
                    
                qual = '+'
                comm = ''
                if k == 'R_id' :
                    if val == None :
                        val = ' '
                        qual = '-'
                        comm = 'DAS serial number not given for this station.'
                    elif not isHex (val) :
                        qual = '?'
                        comm = 'Questionable DAS serial number. Contains non-hex characters.'
                elif k == 'R_station' :
                    if val == None :
                        val = ' '
                        qual = '-'
                        comm = 'Station ID not given.'
                    elif not isNumeric (val) :
                        qual = '?'
                        comm = 'Station ID expected to be numeric'
                elif k == 'R_line' :
                    if val == None :
                        val = ' '
                        qual = '-'
                        comm = 'No line number given.'
                    elif not isNumeric (val) :
                        qual = '?'
                        comm = 'Line number expected to be numeric.'
                elif k == 'R_receiver-type' :
                    if val == None :
                        val = ' '
                        qual = '?'
                        comm = 'Receiver type is blank.'
                elif k == 'R_chan' :
                    if val == None :
                        val = ' '
                        qual = '-'
                        comm = 'Channel number is blank.'
                    elif not isNumeric (val) :
                        qual = '-'
                        comm = 'Channel number is expected to be numeric.'
                    elif int (val) > 6 :
                        qual = '?'
                        comm = 'Channel number should be 1, 2, 3, 4, 5, or 6'
                elif k == 'R_sensor' :
                    if val == None :
                        #qual = '?'
                        comm = 'Sensor serial number.'
                        val = ' '
                elif k == 'R_uphole' :
                    if val == None :
                        val = ' '
                        #qual = '?'
                        comm = 'Uphole phone Y/N?'
                    elif val != 'N' and val != 'Y' :
                        qual = '-'
                        comm = 'Uphole should be "Y" or "N".'
                elif k == 'R_lat' :
                    if val == None :
                        val = ' '
                        qual = '?'
                        comm = 'No latitude given for this station.'
                    else :
                        if float (val) < -90. or float (val) > 90. :
                            qual = '-'
                            comm = 'Latitude is expected to be in the S90 to N90 range.'
                        if float (val) == 0. :
                            qual = '?'
                            comm = 'Questionable lat of 0'
                        if float (val) < 0 :
                            val = val.replace ('-', 'S')
                        else :
                            if val[0] == '+' :
                                val = val.replace ('+', 'N')
                            else :
                                val = 'N' + val
                elif k == 'R_lon' :
                    if val == None :
                        val = ' '
                        qual = '?'
                        comm = 'No longitude given for this station.'
                    else :
                        if float (val) < -180 or float (val) > 180 or float (val) == 0. :
                            qual = '-'
                            comm = 'Longitude is expected to be in the range E180 to W180'
                        if float (val) == 0. :
                            qual = '?'
                            comm = 'Questionable lon of 0'
                        if float (val) < 0 :
                            val = val.replace ('-', 'W')
                        else :
                            if val[0] == '+' :
                                val = val.replace ('+', 'E')
                            else :
                                val = 'E' + val
                elif k == 'R_elev' :
                    if val == None :
                        val = ' '
                        qual = '?'
                        comm = 'No elevation given for station?'
                    else :
                        if not isNumeric (val) :
                            qual = '-'
                            comm = 'Elevation value should be numeric.'
                        elif float (val) < -418. or float (val) > 8848. :
                            qual = '?'
                            comm = 'Elevations normally fall in the range of 418 meters below sealevel to 8848 meters above sealevel.'
                elif k == 'R_team' :
                    if val == None :
                        val = ' '
                        #qual = '?'
                        comm = 'No team name given.'
                elif k == 'R_deploy-epoch' :
                    now = time.time ()
                    if val == None :
                        val = ' '
                        qual = '-'
                        comm = 'No deployment time given.'
                    else :
                        if not isNumeric (val) :
                            qual = '-'
                            comm = 'Epoch time should be numeric.'
                        elif float (val) < 0. or float (val) > now :
                            qual = '?'
                            comm = 'Deploy time appears to be before 1970 or in the future.'
                        val = self.human (val)
                elif k == 'R_pickup-epoch' :
                    now = time.time ()
                    if val == None :
                        val = ' '
                        qual = '-'
                        comm = 'No pickup time given.'
                    else :
                        if not isNumeric (val) :
                            qual = '-'
                            comm = 'Epoch time should be numeric.'
                        elif float (val) < 0. or float (val) > now :
                            qual = '?'
                            comm = 'Pickup time appears to be before 1970 or in the future.'
                        val = self.human (val)
                elif k == 'R_shots' :
                    if val == None :
                        val = ' '
                        qual = '?'
                        comm = 'Shots covered by this receiver.'
                elif k == 'R_comment' :
                    pass
                
                bline.append (Field (val, quality = qual, comment = comm))
                
            bfile.append (bline)
            
        return bfile
            
    def parseRECV (self, line) :
        p = {}
        flds = string.split (line, ';')
        p['what'] = 'RECV'
        try :
            p['R_id'] = string.strip (flds[1])                 #   Receiver ID/serial number
        except IndexError :
            p['R_id'] = None
        try :
            p['R_station'] = str (int (string.strip (flds[2])))            #   Station flag number
        except (IndexError, ValueError) as e :
            p['R_station'] = None
        try :
            p['R_line'] = string.strip (flds[3])               #   Comma separated lines
        except IndexError :
            p['R_line'] = None
        try :
            p['R_receiver-type'] = string.strip (flds[4])      #   Receiver type
        except IndexError :
            p['R_receiver-type'] = None
        try :
            p['R_chan'] = string.strip (flds[5])               #   Receiver channel number
        except IndexError :
            p['R_chan'] = None
        try :
            p['R_sensor'] = string.strip (flds[6])             #   Sensor ID/information
        except IndexError :
            p['R_sensor'] = None
        try :
            p['R_uphole'] = string.strip (flds[7])             #   Was this an uphole instrument? (Y/N)
        except IndexError :
            p['R_uphole'] = None
        try :
            p['R_lat'] = self._sign (string.strip (flds[8]))   #   Latitude
        except IndexError :
            p['R_lat'] = None
        p['R_lat_units'] = 'degrees'
        try :
            p['R_lon'] = self._sign (string.strip (flds[9]))   #   Longitude
        except IndexError :
            p['R_lon'] = None
        p['R_lon_units'] = 'degrees'
        try :
            p['R_elev'] = string.strip (flds[10])              #   Elevation
        except IndexError :
            p['R_elev'] = None
        p['R_elev_units'] = 'meters'
        try :
            p['R_team'] = string.strip (flds[11])              #   Deployment group/team
        except IndexError :
            p['R_team'] = None
        try :
            p['R_array'] = string.strip (flds[3])              #   Line designation
        except IndexError :
            p['R_array'] = None
        try :
            yr, doy, hr, mn, sc = string.split (string.strip (flds[12]), ':')
            p['R_deploy-epoch'] = self.epoch (yr, doy, hr, mn, sc)   #   Deployment time
            p['R_deploy-ascii'] = time.ctime (p['R_deploy-epoch'])   #   Deployment time
            p['R_typed'] = 'BOTH'
            p['R_deploy-ms'] = 0
        except (ValueError, IndexError) as e :
            p['R_deploy-epoch'] = None
            p['R_deploy-ascii'] = ""

        try :
            yr, doy, hr, mn, sc = string.split (string.strip (flds[13]), ':')
            p['R_pickup-epoch'] = self.epoch (yr, doy, hr, mn, sc)   #   Pickup time
            p['R_pickup-ascii'] = time.ctime (p['R_pickup-epoch'])   #   Pickup time
            p['R_typep'] = 'BOTH'
            p['R_pickup-ms'] = 0
        except (ValueError, IndexError) as e :
            p['R_pickup-epoch'] = None
            p['R_pickup-ascii'] = ""
        try :
            p['R_shots'] = string.strip (flds[14])                   #   Shot ID(s) covered by this entry
        except IndexError :
            p['R_shots'] = None 
        try :
            p['R_comment'] = string.strip (flds[15])                 #   Comments
        except :
            p['R_comment'] = ""
        
        return p
    
    def saneMARK (self) :
        order = ('M_id', 'M_route', 'M_lat', 'M_lon', 'M_elev', 'M_comment')
    
    def parseMARK (self, line) :
        p = {}
        flds = string.split (line, ';')
        
        p['what'] = "MARK"
        try :
            p['M_id'] = string.strip (flds[1])
        except IndexError :
            p['M_id'] = None
        try :
            p['M_route'] = string.strip (flds[2])
        except IndexError :
            p['M_route'] = None
        try :
            p['M_lat'] = string.strip (flds[3])
        except IndexError :
            p['M_lat']
        try :
            p['M_lon'] = string.strip (flds[4])
        except IndexError :
            p['M_lon'] = None
        try :
            p['M_elev'] = string.strip (flds[5])
        except IndexError :
            p['M_elev'] = None
        try :
            p['M_comment'] = string.strip (flds[6])
        except IndexError :
            p['M_comment'] = None
        
        return p
    
    def parseTIME (self, line) :
        p = {}
        flds = string.split (line, ';')
        
        p['what'] = "TIME"
        try :
            p['T_file'] = string.strip (flds[1])
        except IndexError :
            p['T_file'] = None
        try :
            p['T_drift'] = string.strip (flds[2])
        except IndexError :
            p['T_drift'] = None
        try :
            p['T_diff'] = string.strip (flds[3])
        except IndexError :
            p['T_diff'] = None
            
        try :
            yr, doy, hr, mn, sc = string.split (string.strip (flds[4]), ':')
            p['T_start-epoch'] = self.epoch (yr, doy, hr, mn, sc)
            p['T_start-ascii'] = time.ctime (p['T_start-epoch'])
            p['T_start-type'] = 'BOTH'
            p['T_start-ms'] = 0
        except ValueError :
            p['T_start-epoch'] = -1
            p['T_start-ascii'] = ""
        
        try :
            yr, doy, hr, mn, sc = string.split (string.strip (flds[5]), ':')
            p['T_end-epoch'] = self.epoch (yr, doy, hr, mn, sc)
            p['T_end-ascii'] = time.ctime (p['T_end-epoch'])
            p['T_end-type'] = 'BOTH'
            p['T_end-ms'] = 0
        except ValueError :
            p['T_end-epoch'] = -1
            p['T_end-ascii'] = ""            
        try :
            p['T_range'] = string.strip (flds[6])
        except IndexError :
            p['T_range'] = None
        try :
            p['T_data_start'] = string.strip (flds[7])
        except IndexError :
            p['T_data_start'] = None
        try :
            p['T_data_end'] = string.strip (flds[8])
        except IndexError :
            p['T_data_end'] = None
        try :
            p['T_data_range'] = string.strip (flds[9])
        except IndexError :
            p['T_data_range'] = None
        try :
            p['T_comment'] = string.strip (flds[10])
        except IndexError :
            p['T_comment'] = None
        
        return p

    def parseBSCN (self, line) :
        p = {}
        flds = string.split (line, ';')
        
        p['what'] = "BSCN"
        try :
            p['B_barcode'] = string.strip (flds[1])
        except IndexError :
            p['B_barcode'] = None
        try :
            p['B_sn'] = string.strip (flds[2])
        except IndexError :
            p['B_sn'] = None
        try :
            p['B_type'] = string.strip (flds[3])
        except IndexError :
            p['B_type'] = None
        try :
            p['B_comment'] = string.strip (flds[4])
        except IndexError :
            p['B_comment'] = None
        
        return p
    
    def nextShot (self) :
        try :
            p = self.currents.pop ()
        except IndexError :
            p = None
            
        return p
    
    def rewindShot (self) :
        self.currents = copy.copy (self.ps)
        self.currents.reverse ()
        
    def setShot (self, ps) :
        self.ps = ps
        
    def genShotLines (self) :
        lines = []
        for s in self.ps :
            flds = []
            for k in Dep.SHOTorder :
                if k == 'S_epoch' :
                    epoch = s[k]
                    if epoch :
                        f = int (epoch)
                        ms = int (((epoch - f) * 1000.) + 0.5)
                        s[k] = self.human (f, ms)
                        
                if latlonRE.match (k) :
                    latlon = s[k]
                    #print latlon,
                    latlon = self._unsign (latlon, k[-3:])
                    s[k] = latlon
                    #print " ", latlon
                    
                flds.append (str (s[k]))
                
            line = 'SHOT;'+';'.join (flds)
            lines.append (line)
            
        return lines
        
    def nextReceiver (self) :
        try :
            p = self.currentr.pop ()
        except IndexError :
            p = None
            
        return p
    
    def rewindReceiver (self) :
        self.currentr = copy.copy (self.pr)
        self.currentr.reverse ()
        
    def setReceiver (self, pr) :
        self.pr = pr
        
    def genReceiverLines (self) :
        lines = []
        for s in self.pr :
            flds = []
            for k in Dep.RECVorder :
                if k == 'R_deploy-epoch' or k == 'R_pickup-epoch' :
                    epoch = s[k]
                    if epoch :
                        f = int (epoch)
                        ms = int (((epoch - f) * 1000.) + 0.5)
                        s[k] = self.human (f, ms)
                        
                if latlonRE.match (k) :
                    latlon = s[k]
                    #print latlon,
                    latlon = self._unsign (latlon, k[-3:])
                    s[k] = latlon
                    #print " ", latlon
                    
                flds.append (str (s[k]))
                
            line = 'RECV;'+';'.join (flds)
            lines.append (line)
            
        return lines        
        
    def nextTime (self) :
        try :
            p = self.currentt.pop ()
        except IndexError :
            p = None
            
        return p
    
    def rewindTime (self) :
        self.currentt = copy.copy (self.pt)
        self.currentt.reverse ()
    
    def read (self) :
        self.ps = []
        self.pr = []
        self.pt = []
        while 1 :
            line = self.fh.readline ()
            if not line : break
            if len (line) < 5 : continue
            
            #   User wants us to ignore this line
            if line[5] == 'X' :
                continue
            
            if line[0:4] == 'SHOT' :                
                p = self.parseSHOT (line)
                self.ps.append (p)
            elif line[0:4] == 'RECV' :
                p = self.parseRECV (line)
                self.pr.append (p)
            elif line[0:4] == 'MARK' :
                p = self.parseMARK (line)
            elif line[0:4] == 'TIME' :
                p = self.parseTIME (line)
                self.pt.append (p)
            elif line[0:4] == 'BCSN' :
                p = self.parseBSCN (line)
            else :
                continue
            
    #   XXX   Match to Kitchen keys   XXX
    def _build (self, p) :
        keys = p.keys ()
        
        E_t = {}
        A_t = {}
        #R_t = {}
        S_t = {}
        T_t = {}
        big = {}
        for k in keys :
            if Match_Event_t.has_key (k) :
                mk = Match_Event_t[k]
                E_t[mk] = p[k]
                
            elif Match_Array_t.has_key (k) :
                mk = Match_Array_t[k]
                A_t[mk] = p[k]
                
            #elif Match_Receiver_t.has_key (k) :
                #mk = Match_Receiver_t[k]
                #R_t[mk] = p[k]
                
            elif Match_Sort_t.has_key (k) :
                mk = Match_Sort_t[k]
                S_t[mk] = p[k]
                
            elif Match_Time_t.has_key (k) :
                mk = Match_Time_t[k]
                T_t[mk] = p[k]
                
            else :
                pass
                #print "oops...ignoring ", k
                
        big['Event_t'] = E_t
        big['Array_t'] = A_t
        #big['Receiver_t'] = R_t
        big['Sort_t'] = S_t
        big['Time_t'] = T_t
        
        return big

    ##   XXX   This belongs somewhere else   XXX
    #def batch_update (self, ex) :
        #self.rewindReceiver ()
        #self.rewindShot ()
        
        ##   Populate shot table Event_t  
        ##print "Event_t"
        #while 1 :
            #p = self.nextShot ()
            #if not p : break
            #b = self._build (p)
            #b = b['Event_t']
            #ex.ph5_g_sorts.populateEvent_t (b)
        
        ##   Populate receiver table Receiver_t
        ##print "Receiver_t"
        #while 1 :
            #das = None
            #p = self.nextReceiver ()
            #if not p : break
            #if p.has_key ('R_id') :
                #das = p['R_id']
            #else :
                #sys.stderr.write ("Warning: No das listed on RECV\n")
                #continue
                
            #das_g = ex.ph5_g_receivers.getdas_g (das)
            #if not das_g :
                #sys.stderr.write ("Warning: No entry in ph5 file for DAS %s\n" % das)
                #continue
            
            #b = self._build (p)
            #b = b['Receiver_t']
            
            #ex.ph5_g_receivers.populateReceiver_t (b)
            
        #self.rewindReceiver ()
        ##self.rewindShot ()
        #current_array = None
        #ref = None
        ##   Populate Sort_t and Array_t tables
        ##   XXX   Assumes that Line designation is grouped together in dep file   XXX
        #while 1 :
            #p = self.nextReceiver ()
            #if not p : break
            #b = self._build (p)
            #tmp = p['R_array']
            ##   
            #if tmp != current_array :
                #current_array = tmp
                #next = ex.ph5_g_sorts.nextName ()
                #ref = ex.ph5_g_sorts.newSort (next)
                #s = b['Sort_t']
                #s['array_t_name_s'] = next
                ##print "Sort_t"
                #ex.ph5_g_sorts.populateSort_t (s)
                
            #a = b['Array_t']
            ##print "Array_t"
            #ex.ph5_g_sorts.populateArray_t (a)
            
def isNumeric (a) :
    try :
        float (a)
    except (ValueError, TypeError) as e :
        return False
    
    return True

def isHex (a) :
    try :
        int (a, 16)
    except (ValueError, TypeError) as e :
        return False
    
    return True
                    
if __name__ == '__main__' :
    import os, Experiment
    def print_it (t, p) :
        print t
        for k, v in p.items () :
            print '\t', k, ' = ', v
            
    dp = Dep ('passcal1.dep')
    dp.open ()
    dp.read ()
    #dp.batch_update (ex)
    dp.rewindShot ()
    shotFile = dp.saneSHOT ()
    
    for shotLine in shotFile :
        print "SHOT;",
        for val in shotLine :
            print "%s %s;" % (val.value, val.quality),
        print
       
    #sys.exit ()
    dp.rewindReceiver ()
    recvFile = dp.saneRECV ()
    for recvLine in recvFile :
        print "RECV;",
        for val in recvLine :
            print "%s %s;" % (val.value, val.quality),
        print
    sys.exit ()
    dp.rewindTime ()
    while 1 :
        p = dp.nextShot ()
        if not p : break
        print_it ('Shot:', p)
        
    while 1 :
        p = dp.nextReceiver ()
        if not p : break
        print_it ('Receiver:', p)    
            
    while 1 :
        p = dp.nextTime ()
        if not p : break
        print_it ('Time:', p)
