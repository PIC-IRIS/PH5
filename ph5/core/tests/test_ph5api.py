'''
Tests for ph5api
'''
import os
import sys
import unittest

from mock import patch

from ph5.utilities import segd2ph5, initialize_ph5
from ph5.core import ph5api
from ph5.core.tests.test_base import LogTestCase, TempDirTestCase


class TestPH5API(LogTestCase):
    def setUp(self):
        super(TestPH5API, self).setUp()
        self.home = os.getcwd()
        self.ph5API_object = ph5api.PH5(
            path=os.path.join(self.home, 'ph5/test_data/ph5'),
            nickname='master.ph5')

    def tearDown(self):
        self.ph5API_object.close()
        super(TestPH5API, self).tearDown()

    def test_load_ph5(self):
        """
        Tries to load the PH5 test file.
        Checks if it is an instance of ph5.core.ph5api.PH5
        """
        self.assertTrue(isinstance(self.ph5API_object, ph5api.PH5))
        self.assertTrue(self.ph5API_object.ph5.isopen)

    def test_experiment_t(self):
        """
        check reading of experiment table
        """

        # experiment table is initally empty
        self.assertIsNone(self.ph5API_object.Experiment_t)
        # load experiment table and it shouldn't be empty

        self.ph5API_object.read_experiment_t()
        self.assertIsNotNone(self.ph5API_object.Experiment_t)

        # keys should match
        keys = ['experiment_id_s', 'net_code_s', 'nickname_s', 'longname_s',
                'PIs_s', 'institutions_s', 'north_west_corner/X/value_d',
                'north_west_corner/X/units_s', 'north_west_corner/Y/value_d',
                'north_west_corner/Y/units_s', 'north_west_corner/Z/value_d',
                'north_west_corner/Z/units_s',
                'north_west_corner/coordinate_system_s',
                'north_west_corner/projection_s',
                'north_west_corner/ellipsoid_s',
                'north_west_corner/description_s',
                'south_east_corner/X/value_d', 'south_east_corner/X/units_s',
                'south_east_corner/Y/value_d', 'south_east_corner/Y/units_s',
                'south_east_corner/Z/value_d', 'south_east_corner/Z/units_s',
                'south_east_corner/coordinate_system_s',
                'south_east_corner/projection_s',
                'south_east_corner/ellipsoid_s',
                'south_east_corner/description_s', 'summary_paragraph_s',
                'time_stamp/ascii_s', 'time_stamp/epoch_l',
                'time_stamp/micro_seconds_i', 'time_stamp/type_s']
        self.assertEqual(keys, self.ph5API_object.Experiment_t['keys'])

        # expect only one row in experiment table
        self.assertEqual(1, len(self.ph5API_object.Experiment_t['rows']))

        # make sure experiment table matches what we think it should
        experiment_t = self.ph5API_object.Experiment_t['rows']
        experiment_t[0]['net_code_s']
        self.assertEqual(experiment_t[0]['net_code_s'], 'AA')
        self.assertEqual(experiment_t[0]['experiment_id_s'], '99-999')
        self.assertEqual(experiment_t[0]['nickname_s'], 'PH5 Test')
        self.assertEqual(experiment_t[0]['longname_s'], 'PH5 TEST SET')
        self.assertEqual(experiment_t[0]['PIs_s'], 'Derick Hess')
        self.assertEqual(experiment_t[0]['institutions_s'], 'PASSCAL')

    def test_array_t(self):

        # make sure array_t_names is empty then load them
        # and make sure they match expected array names
        self.assertFalse(self.ph5API_object.Array_t_names)
        self.ph5API_object.read_array_t_names()
        self.assertTrue(self.ph5API_object.Array_t_names)
        self.assertTrue('Array_t_001' in self.ph5API_object.Array_t_names)
        self.assertEqual([1, 2, 3],
                         self.ph5API_object.channels_Array_t('Array_t_001'))
        self.assertTrue('Array_t_002' in self.ph5API_object.Array_t_names)
        self.assertEqual([1],
                         self.ph5API_object.channels_Array_t('Array_t_002'))
        self.assertTrue('Array_t_003' in self.ph5API_object.Array_t_names)
        self.assertEqual([1],
                         self.ph5API_object.channels_Array_t('Array_t_003'))
        self.assertTrue('Array_t_004' in self.ph5API_object.Array_t_names)
        self.assertEqual([-2],
                         self.ph5API_object.channels_Array_t('Array_t_004'))
        self.assertTrue('Array_t_008' in self.ph5API_object.Array_t_names)
        self.assertEqual([1, 2, 3],
                         self.ph5API_object.channels_Array_t('Array_t_008'))
        self.assertTrue('Array_t_009' in self.ph5API_object.Array_t_names)
        self.assertEqual([1],
                         self.ph5API_object.channels_Array_t('Array_t_009'))

        # now test to see if certain value are in each array as expected

        # checking 3rd channel of array 1... auto generated by segdtoph5
        self.assertFalse(hasattr(self.ph5API_object.Array_t, 'Array_t_001'))
        self.ph5API_object.read_array_t('Array_t_001')

        # check keys
        keys = ['id_s', 'location/X/value_d', 'location/X/units_s',
                'location/Y/value_d', 'location/Y/units_s',
                'location/Z/value_d', 'location/Z/units_s',
                'location/coordinate_system_s', 'location/projection_s',
                'location/ellipsoid_s', 'location/description_s',
                'deploy_time/ascii_s', 'deploy_time/epoch_l',
                'deploy_time/micro_seconds_i', 'deploy_time/type_s',
                'pickup_time/ascii_s', 'pickup_time/epoch_l',
                'pickup_time/micro_seconds_i', 'pickup_time/type_s',
                'das/serial_number_s', 'das/model_s', 'das/manufacturer_s',
                'das/notes_s', 'sensor/serial_number_s', 'sensor/model_s',
                'sensor/manufacturer_s', 'sensor/notes_s', 'description_s',
                'seed_band_code_s', 'sample_rate_i',
                'sample_rate_multiplier_i', 'seed_instrument_code_s',
                'seed_orientation_code_s', 'seed_location_code_s',
                'seed_station_name_s', 'channel_number_i',
                'receiver_table_n_i', 'response_table_n_i']

        self.assertEqual(keys,
                         self.ph5API_object.Array_t['Array_t_001']['keys'])

        self.assertEqual([1, 2, 3],
                         self.ph5API_object.channels('Array_t_001', '500'))
        channel = self.ph5API_object.Array_t['Array_t_001']['byid']\
            .get('500').get(3)
        self.assertEqual(channel[0]['id_s'], '500')
        self.assertEqual(channel[0]['seed_station_name_s'], '500')
        self.assertEqual(channel[0]['das/serial_number_s'], '3X500')
        self.assertAlmostEqual(channel[0]['location/X/value_d'],
                               -105.405489539,
                               9)
        self.assertAlmostEqual(channel[0]['location/Y/value_d'],
                               47.6790599342,
                               9)
        self.assertEqual(channel[0]['location/Z/value_d'], 0.0)
        self.assertEqual(channel[0]['das/model_s'], 'ZLAND 3C')
        self.assertEqual(channel[0]['sample_rate_i'], 500)
        self.assertEqual(channel[0]['sample_rate_multiplier_i'], 1)
        self.assertEqual(channel[0]['seed_band_code_s'], 'D')
        self.assertEqual(channel[0]['seed_instrument_code_s'], 'P')
        self.assertEqual(channel[0]['seed_orientation_code_s'], 'Z')
        self.assertEqual(channel[0]['receiver_table_n_i'], 0)
        self.assertEqual(channel[0]['response_table_n_i'], 0)
        self.assertEqual(channel[0]['channel_number_i'], 3)

        # checking 1st channel of array 2... auto generated by obsoytoph5

        self.assertFalse(hasattr(self.ph5API_object.Array_t, 'Array_t_002'))
        self.assertEqual([1],
                         self.ph5API_object.channels('Array_t_002', '0407'))
        self.ph5API_object.read_array_t('Array_t_002')
        channel = self.ph5API_object.Array_t['Array_t_002']['byid'] \
            .get('0407').get(1)
        self.assertEqual(channel[0]['id_s'], '0407')
        self.assertEqual(channel[0]['seed_station_name_s'], '0407')
        self.assertEqual(channel[0]['das/serial_number_s'], '5553')
        self.assertEqual(channel[0]['location/X/value_d'], 94.88888)
        self.assertEqual(channel[0]['location/Y/value_d'], 73.77777)
        self.assertEqual(channel[0]['location/Z/value_d'], 90.0)
        self.assertEqual(channel[0]['sample_rate_i'], 200)
        self.assertEqual(channel[0]['sample_rate_multiplier_i'], 1)
        self.assertEqual(channel[0]['seed_band_code_s'], 'H')
        self.assertEqual(channel[0]['seed_instrument_code_s'], 'H')
        self.assertEqual(channel[0]['seed_orientation_code_s'], 'N')
        self.assertEqual(channel[0]['receiver_table_n_i'], 1)
        self.assertEqual(channel[0]['response_table_n_i'], 5)
        self.assertEqual(channel[0]['channel_number_i'], 1)

        # checking 1st channel of array 4... auto generated by obsoytoph5
        # LOG so channel -2
        self.assertFalse(hasattr(self.ph5API_object.Array_t, 'Array_t_004'))
        self.assertEqual([-2],
                         self.ph5API_object.channels('Array_t_004', '0407'))
        self.ph5API_object.read_array_t('Array_t_004')
        channel = self.ph5API_object.Array_t['Array_t_004']['byid'] \
            .get('0407').get(-2)
        self.assertEqual(channel[0]['id_s'], '0407')
        self.assertEqual(channel[0]['seed_station_name_s'], '0407')
        self.assertEqual(channel[0]['das/serial_number_s'], '5553')
        self.assertEqual(channel[0]['location/X/value_d'], 94.88888)
        self.assertEqual(channel[0]['location/Y/value_d'], 73.77777)
        self.assertEqual(channel[0]['location/Z/value_d'], 90.0)
        self.assertEqual(channel[0]['sample_rate_i'], 0)
        self.assertEqual(channel[0]['sample_rate_multiplier_i'], 1)
        self.assertEqual(channel[0]['seed_band_code_s'], 'L')
        self.assertEqual(channel[0]['seed_instrument_code_s'], 'O')
        self.assertEqual(channel[0]['seed_orientation_code_s'], 'G')
        self.assertEqual(channel[0]['receiver_table_n_i'], 1)
        self.assertEqual(channel[0]['response_table_n_i'], -1)
        self.assertEqual(channel[0]['channel_number_i'], -2)

        # checking 2nd channel of array 8... hand created loaded by keftoph5
        self.assertFalse(hasattr(self.ph5API_object.Array_t, 'Array_t_008'))
        self.assertEqual([1, 2, 3],
                         self.ph5API_object.channels('Array_t_008', '8001'))
        self.ph5API_object.read_array_t('Array_t_008')
        channel = self.ph5API_object.Array_t['Array_t_008']['byid'] \
            .get('8001').get(2)
        self.assertEqual(channel[0]['id_s'], '8001')
        self.assertEqual(channel[0]['seed_station_name_s'], '8001')
        self.assertEqual(channel[0]['das/serial_number_s'], '9EEF')
        self.assertEqual(channel[0]['location/X/value_d'], -106.916169)
        self.assertEqual(channel[0]['location/Y/value_d'], 34.154673)
        self.assertEqual(channel[0]['location/Z/value_d'], 1403.0)
        self.assertEqual(channel[0]['sample_rate_i'], 100)
        self.assertEqual(channel[0]['sample_rate_multiplier_i'], 1)
        self.assertEqual(channel[0]['seed_band_code_s'], 'H')
        self.assertEqual(channel[0]['seed_instrument_code_s'], 'L')
        self.assertEqual(channel[0]['seed_orientation_code_s'], '1')
        self.assertEqual(channel[0]['receiver_table_n_i'], 1)
        # there is no n_i=7 in response_t
        self.assertEqual(channel[0]['response_table_n_i'], 2)
        self.assertEqual(channel[0]['channel_number_i'], 2)

        # array shouldn't have station 0407
        self.assertEqual([],
                         self.ph5API_object.channels('Array_t_008', '0407'))
        # array 9 should have channels
        self.assertNotEqual([],
                            self.ph5API_object.channels('Array_t_009',
                                                        '9001'))
        # array 1 should have channels
        self.assertNotEqual([],
                            self.ph5API_object.channels_Array_t(
                                'Array_t_001'))
        # no array 0
        self.assertFalse('Array_t_000' in self.ph5API_object.Array_t_names)

        # no array 5
        self.assertFalse('Array_t_005' in self.ph5API_object.Array_t_names)

    def test_index_t(self):
        """
        Test reading of index table and checking contents
        """
        # able to read index table
        self.assertFalse(self.ph5API_object.Index_t)
        self.ph5API_object.read_index_t()
        self.assertTrue(self.ph5API_object.Index_t)

        # it contains keys adn they are correct
        self.assertTrue(self.ph5API_object.Index_t['keys'])
        keys = ['end_time/ascii_s', 'end_time/epoch_l',
                'end_time/micro_seconds_i', 'end_time/type_s',
                'external_file_name_s', 'hdf5_path_s', 'serial_number_s',
                'start_time/ascii_s', 'start_time/epoch_l',
                'start_time/micro_seconds_i', 'start_time/type_s',
                'time_stamp/ascii_s', 'time_stamp/epoch_l',
                'time_stamp/micro_seconds_i', 'time_stamp/type_s']
        self.assertEqual(keys, self.ph5API_object.Index_t['keys'])

        # are there as many rows as we expect?
        self.assertEqual(11, len(self.ph5API_object.Index_t['rows']))

        # check row 6.
        self.assertEqual('3X500',
                         self.ph5API_object.Index_t['rows'][5]
                         ['serial_number_s'])

    def test_receiver_t(self):
        """
        test reading receiver table
        :return:
        """
        # able to read index table
        self.assertFalse(self.ph5API_object.Receiver_t)
        self.ph5API_object.read_receiver_t()
        self.assertTrue(self.ph5API_object.Receiver_t)
        keys = ['orientation/azimuth/value_f',
                'orientation/azimuth/units_s',
                'orientation/dip/value_f',
                'orientation/dip/units_s',
                'orientation/description_s',
                'orientation/channel_number_i']
        self.assertEqual(keys, self.ph5API_object.Receiver_t['keys'])

        # expect 4 rows in receiver table
        self.assertEqual(4, len(self.ph5API_object.Receiver_t['rows']))

        # get each receiver table entry by it's n_i number
        table = self.ph5API_object.get_receiver_t_by_n_i(0)
        self.assertEqual(0.0, table['orientation/azimuth/value_f'])
        self.assertEqual(90.0, table['orientation/dip/value_f'])
        self.assertEqual('Z', table['orientation/description_s'])
        table = self.ph5API_object.get_receiver_t_by_n_i(1)
        self.assertEqual(0.0, table['orientation/azimuth/value_f'])
        self.assertEqual(0.0, table['orientation/dip/value_f'])
        self.assertEqual('N', table['orientation/description_s'])
        table = self.ph5API_object.get_receiver_t_by_n_i(2)
        self.assertEqual(90.0, table['orientation/azimuth/value_f'])
        self.assertEqual(0.0, table['orientation/dip/value_f'])
        self.assertEqual('E', table['orientation/description_s'])
        table = self.ph5API_object.get_receiver_t_by_n_i(3)
        self.assertEqual(0.0, table['orientation/azimuth/value_f'])
        self.assertEqual(-90.0, table['orientation/dip/value_f'])
        self.assertEqual('Z', table['orientation/description_s'])

    def test_das_t(self):
        # read in das group names
        self.assertFalse(self.ph5API_object.Das_g_names)
        self.ph5API_object.read_das_g_names()
        self.assertTrue(self.ph5API_object.Das_g_names)

        # check that all dases are there
        # rt125a das
        self.assertTrue('Das_g_12183' in self.ph5API_object.Das_g_names)
        # rt130 das
        self.assertTrue('Das_g_9EEF' in self.ph5API_object.Das_g_names)
        # Node das
        self.assertTrue('Das_g_3X500' in self.ph5API_object.Das_g_names)
        # miniSEED das
        self.assertTrue('Das_g_5553' in self.ph5API_object.Das_g_names)

        #  test various read methods
        # should NOT return anything
        table = self.ph5API_object.query_das_t('3X500',
                                               chan=8,
                                               start_epoch=1502293592,
                                               stop_epoch=1502309218,
                                               sample_rate=500,
                                               sample_rate_multiplier=1)
        self.assertFalse(table)
        self.ph5API_object.forget_das_t('3X500')

        # should return anything
        table = self.ph5API_object.query_das_t('3X500',
                                               chan=1,
                                               start_epoch=1502294430.380000,
                                               stop_epoch=1502309218,
                                               sample_rate=500,
                                               sample_rate_multiplier=1)

        self.assertTrue(table)
        self.assertEqual(1, len(table))
        # we should get the 2nd recording window
        self.assertEqual(2, table[0]['event_number_i'])
        self.ph5API_object.forget_das_t('3X500')

        # test query LOG channel
        table = self.ph5API_object.query_das_t('5553',
                                               chan=-2,
                                               start_epoch=1545088203,
                                               stop_epoch=1547489525,
                                               sample_rate=0,
                                               sample_rate_multiplier=1)
        self.assertTrue(table)
        self.assertEqual(1, len(table))
        # no samples in a textural LOG
        self.assertEqual(0, table[0]['sample_count_i'])
        self.ph5API_object.forget_das_t('5553')

        # check read_das_t now
        # read entire rt125a das table
        self.ph5API_object.read_das_t('12183')
        # we expect 9 rows
        self.assertTrue(9, len(self.ph5API_object.Das_t['12183']['rows']))
        # check that all the keys are there
        keys = ['array_name_SOH_a', 'array_name_data_a', 'array_name_event_a',
                'array_name_log_a', 'channel_number_i', 'event_number_i',
                'raw_file_name_s', 'receiver_table_n_i', 'response_table_n_i',
                'sample_count_i', 'sample_rate_i', 'sample_rate_multiplier_i',
                'stream_number_i', 'time/ascii_s', 'time/epoch_l',
                'time/micro_seconds_i', 'time/type_s', 'time_table_n_i']
        self.assertEqual(keys, self.ph5API_object.Das_t['12183']['keys'])
        # check an entry to make sure it is what we expect
        self.assertEqual(1550850153,
                         self.ph5API_object.Das_t['12183']['rows']
                         [7]['time/epoch_l'])

        # forget 12183 and read time range
        self.ph5API_object.forget_das_t('12183')
        self.assertFalse(hasattr(self.ph5API_object.Das_t, '12183'))
        self.ph5API_object.read_das_t('12183', start_epoch=1550850093,
                                      stop_epoch=1550850152)
        # we should get 2 rows
        self.assertTrue(2, len(self.ph5API_object.Das_t['12183']['rows']))

        # rows should be for data array 6 and 7
        self.assertEqual('Data_a_0006',
                         self.ph5API_object.Das_t['12183']['rows']
                         [0]['array_name_data_a'])

        self.assertEqual('Data_a_0007',
                         self.ph5API_object.Das_t['12183']['rows']
                         [1]['array_name_data_a'])
        self.ph5API_object.forget_das_t('12183')
        # read das with multiple channels
        self.ph5API_object.read_das_t('9EEF')
        # we expect 3 rows and expect row 0 to be ch 1, 1 to be ch 2
        # and 2, to be ch 3
        self.assertTrue(3, len(self.ph5API_object.Das_t['9EEF']['rows']))
        self.assertEqual(1,
                         self.ph5API_object.Das_t['9EEF']['rows']
                         [0]['channel_number_i'])
        self.assertEqual(2,
                         self.ph5API_object.Das_t['9EEF']['rows']
                         [1]['channel_number_i'])
        self.assertEqual(3,
                         self.ph5API_object.Das_t['9EEF']['rows']
                         [2]['channel_number_i'])

        self.ph5API_object.forget_das_t('9EEF')

    def test_time_t(self):
        """
        tests reading of time_t
        """
        self.assertFalse(self.ph5API_object.Time_t)
        self.ph5API_object.read_time_t()
        self.assertTrue(self.ph5API_object.Time_t)

        keys = ['corrected_i', 'das/serial_number_s', 'das/model_s',
                'das/manufacturer_s', 'das/notes_s', 'description_s',
                'end_time/ascii_s', 'end_time/epoch_l',
                'end_time/micro_seconds_i', 'end_time/type_s', 'offset_d',
                'slope_d', 'start_time/ascii_s', 'start_time/epoch_l',
                'start_time/micro_seconds_i', 'start_time/type_s']
        self.assertEqual(keys, self.ph5API_object.Time_t['keys'])

        # check an entry to make sure it is what we expect
        self.assertEqual(-8.10623e-06,
                         self.ph5API_object.Time_t['rows'][0]['offset_d'])
        self.assertEqual(-1.66452e-09,
                         self.ph5API_object.Time_t['rows'][0]['slope_d'])

        # get a time_t for a specific das
        # first try one that doesn't exist
        table = self.ph5API_object.get_time_t('12345')
        self.assertFalse(table)
        # now get a real one
        table = self.ph5API_object.get_time_t('12183')
        self.assertTrue(table)
        self.assertEqual('12183',
                         table[0]['das/serial_number_s'])
        self.assertEqual(-8.10623e-06,
                         table[0]['offset_d'])
        self.assertEqual(-1.66452e-09,
                         table[0]['slope_d'])

    def test_response_t(self):
        """
        test reading of response table
        """
        self.assertFalse(self.ph5API_object.Response_t)
        self.ph5API_object.read_response_t()
        self.assertTrue(self.ph5API_object.Response_t)

        keys = ['n_i', 'bit_weight/value_d', 'bit_weight/units_s',
                'gain/units_s', 'gain/value_i', 'response_file_a',

                'response_file_das_a', 'response_file_sensor_a']
        self.assertEqual(keys, self.ph5API_object.Response_t['keys'])

        # check an entry to make sure it is what we expect
        self.assertAlmostEqual(1.88039941931e-05,
                               self.ph5API_object.Response_t['rows'][0]
                               ['bit_weight/value_d'],
                               16)
        self.assertEqual('/Experiment_g/Responses_g/ZLAND3C_500_1_24',
                         self.ph5API_object.Response_t['rows'][0]
                         ['response_file_das_a'])
        self.assertEqual('',
                         self.ph5API_object.Response_t['rows'][0]
                         ['response_file_sensor_a'])

        self.assertEqual(1.584,
                         self.ph5API_object.Response_t['rows'][1]
                         ['bit_weight/value_d'])
        self.assertEqual('/Experiment_g/Responses_g/rt130_100_1_1',
                         self.ph5API_object.Response_t['rows'][1]
                         ['response_file_das_a'])
        self.assertEqual('/Experiment_g/Responses_g/cmg3t',
                         self.ph5API_object.Response_t['rows'][1]
                         ['response_file_sensor_a'])

        self.assertEqual(0.0,
                         self.ph5API_object.Response_t['rows'][5]
                         ['bit_weight/value_d'])
        self.assertEqual(
            '/Experiment_g/Responses_g/NoneQ330_NoneCMG3T_200HHN',
            self.ph5API_object.Response_t['rows'][5]
            ['response_file_das_a'])
        self.assertEqual('',
                         self.ph5API_object.Response_t['rows'][5]
                         ['response_file_sensor_a'])

        self.assertAlmostEqual(5.96046447754e-08,
                               self.ph5API_object.Response_t['rows'][4]
                               ['bit_weight/value_d'],
                               16)
        self.assertEqual('/Experiment_g/Responses_g/rt125a_500_1_32',
                         self.ph5API_object.Response_t['rows'][4]
                         ['response_file_das_a'])
        self.assertEqual('/Experiment_g/Responses_g/gs11v',
                         self.ph5API_object.Response_t['rows'][4]
                         ['response_file_sensor_a'])

        # response table for specific das
        self.ph5API_object.read_das_t('12183')
        # should fail giving it rows and keys
        table = self.ph5API_object.get_response_t(
            self.ph5API_object.Das_t['12183'])
        self.assertFalse(table)
        # should read given only rows
        table = self.ph5API_object.get_response_t(
            self.ph5API_object.Das_t['12183']['rows'])
        self.assertTrue(table)
        # table values are as expected
        self.assertEqual(4, table['n_i'])
        self.assertAlmostEqual(5.96046447754e-08,
                               table['bit_weight/value_d'],
                               16)
        self.assertEqual('/Experiment_g/Responses_g/rt125a_500_1_32',
                         table['response_file_das_a'])
        self.assertEqual('/Experiment_g/Responses_g/gs11v',
                         table['response_file_sensor_a'])

        # response table by n_i
        # shouldn't exist
        table = self.ph5API_object.get_response_t_by_n_i(99)
        self.assertFalse(table)
        # get a good entry by n_i
        table = self.ph5API_object.get_response_t_by_n_i(6)
        self.assertTrue(table)
        self.assertEqual(6, table['n_i'])
        self.assertEqual(0.0, table['bit_weight/value_d'])
        self.assertEqual(
            '/Experiment_g/Responses_g/NoneQ330_NoneCMG3T_100LHN',
            table['response_file_das_a'])
        self.assertEqual('',
                         table['response_file_sensor_a'])

    def test_offset_t(self):
        """
        test methods related to reading offset table
        """

        # get list of offset_t names
        self.assertFalse(self.ph5API_object.Offset_t_names)
        self.ph5API_object.read_offset_t_names()
        self.assertTrue(self.ph5API_object.Offset_t_names)
        self.assertEqual(['Offset_t_001_001',
                          'Offset_t_008_001',
                          'Offset_t_002_001',
                          'Offset_t_004_001',
                          'Offset_t_009_001',
                          'Offset_t_003_001'],
                         self.ph5API_object.Offset_t_names)

        # read an offset_t
        self.assertFalse(hasattr(self.ph5API_object.Offset_t,
                                 'Offset_t_001_001'))
        self.ph5API_object.read_offset_t(
            'Offset_t_001_001',
            id_order='event_id_s')
        self.assertTrue(self.ph5API_object.Offset_t['Offset_t_001_001'])
        keys = ['azimuth/value_f', 'azimuth/units_s', 'event_id_s',
                'offset/value_d', 'offset/units_s', 'receiver_id_s']
        self.assertEqual(keys,
                         self.ph5API_object.Offset_t
                         ['Offset_t_001_001']['keys'])
        # doesn't exist
        # read an offset_t
        self.assertFalse(hasattr(self.ph5API_object.Offset_t,
                                 'Offset_t_099_123'))
        self.ph5API_object.read_offset_t(
            'Offset_t_099_123',
            id_order='event_id_s')
        self.assertFalse(hasattr(self.ph5API_object.Offset_t,
                                 'Offset_t_099_123'))

        # read an offset_t
        self.assertFalse(hasattr(self.ph5API_object.Offset_t,
                                 'Offset_t_008_001'))
        self.ph5API_object.read_offset_t(
            'Offset_t_008_001',
            id_order='receiver_id_s')
        self.assertTrue(self.ph5API_object.Offset_t['Offset_t_008_001'])

        # shot order offsets
        # should exist offset_t
        offset_t = self.ph5API_object.read_offsets_shot_order(
            'Array_t_009',
            '7001',
            'Event_t_001')
        # check metadata is correct
        self.assertEqual('7001', offset_t['9001']['event_id_s'])
        self.assertEqual(-7673.76009838, offset_t['9001']['offset/value_d'])
        self.assertEqual(
            -4.136306285858154, offset_t['9001']['azimuth/value_f'])
        self.assertEqual('9001', offset_t['9001']['receiver_id_s'])
        # should not exist offset_t
        offset_t = self.ph5API_object.read_offsets_shot_order(
            'Array_t_009',
            '7002',
            'Event_t_001')
        self.assertFalse(offset_t['9001'])

        # receiver order offsets
        # should exist
        offset_t = self.ph5API_object.read_offsets_receiver_order(
            'Array_t_009',
            '9001',
            'Event_t_001')
        # check metadata is correct
        self.assertEqual('7001', offset_t['7001']['event_id_s'])
        self.assertEqual(-7673.76009838, offset_t['7001']['offset/value_d'])
        self.assertEqual(
            -4.136306285858154, offset_t['7001']['azimuth/value_f'])
        self.assertEqual('9001', offset_t['7001']['receiver_id_s'])
        # should not exist offset_t
        offset_t = self.ph5API_object.read_offsets_receiver_order(
            'Array_t_009',
            '9002',
            'Event_t_001')
        self.assertFalse(offset_t['7001'])

        # test calculating offsets
        offset_t = self.ph5API_object.calc_offsets(
            'Array_t_009',
            '7001',
            'Event_t_001')
        keys = ['event_id_s', 'offset/value_d', 'azimuth/units_s',
                'offset/units_s', 'receiver_id_s', 'azimuth/value_f']
        self.assertEqual(keys, offset_t['keys'])
        self.assertEqual('7001', offset_t['byid']['9001']['event_id_s'])
        self.assertAlmostEqual(-7673.76009838,
                               offset_t['byid']['9001']['offset/value_d'], 6)
        self.assertAlmostEqual(-4.136306285858154,
                               offset_t['byid']['9001']['azimuth/value_f'], 6)
        self.assertEqual('9001', offset_t['byid']['9001']['receiver_id_s'])

        # get offset
        offset_t = self.ph5API_object.get_offset(
            'Array_t_009',
            '9001',
            'Event_t_001',
            '7001')
        self.assertEqual('7001', offset_t['event_id_s'])
        self.assertEqual('9001', offset_t['receiver_id_s'])
        self.assertAlmostEqual(abs(-7673.76009838),
                               offset_t['offset/value_d'], 6)
        self.assertAlmostEqual(-4.136306285858154,
                               offset_t['azimuth/value_f'], 6)
        # get offset doesn't exist
        offset_t = self.ph5API_object.get_offset(
            'Array_t_009',
            '9002',
            'Event_t_001',
            '7001')
        self.assertFalse(offset_t)

    def test_event_t(self):
        """
        test methodfs related to event tables
        """
        # test reading event table names
        self.assertFalse(self.ph5API_object.Event_t_names)
        self.ph5API_object.read_event_t_names()
        self.assertTrue(self.ph5API_object.Event_t_names)
        self.assertEqual(1, len(self.ph5API_object.Event_t_names))
        self.assertEqual('Event_t_001', self.ph5API_object.Event_t_names[0])

        # read event_t
        self.assertFalse(hasattr(self.ph5API_object.Event_t, 'Event_t_001'))
        self.ph5API_object.read_event_t('Event_t_001')
        self.assertTrue(self.ph5API_object.Event_t['Event_t_001'])
        keys = ['id_s', 'location/X/value_d', 'location/X/units_s',
                'location/Y/value_d', 'location/Y/units_s',
                'location/Z/value_d', 'location/Z/units_s',
                'location/coordinate_system_s', 'location/projection_s',
                'location/ellipsoid_s', 'location/description_s',
                'time/ascii_s', 'time/epoch_l', 'time/micro_seconds_i',
                'time/type_s', 'size/value_d', 'size/units_s',
                'depth/value_d', 'depth/units_s', 'description_s']

        self.assertEqual(keys,
                         self.ph5API_object.Event_t['Event_t_001']['keys'])
        self.assertEqual(1550850060,
                         self.ph5API_object.Event_t['Event_t_001']['byid']
                         ['7001']['time/epoch_l'])

    def test_sort_t(self):
        """
        test methods related to sort_t
        """

        # read the sort_t
        self.assertFalse(self.ph5API_object.Sort_t)
        self.ph5API_object.read_sort_t()
        self.assertTrue(self.ph5API_object.Sort_t)
        self.assertTrue('Array_t_001' in self.ph5API_object.Sort_t)
        self.assertTrue('Array_t_002' in self.ph5API_object.Sort_t)
        self.assertTrue('Array_t_003' in self.ph5API_object.Sort_t)
        self.assertTrue('Array_t_008' in self.ph5API_object.Sort_t)
        self.assertTrue('Array_t_009' in self.ph5API_object.Sort_t)
        # shouldn't exist
        self.assertFalse('Array_t_006' in self.ph5API_object.Sort_t)
        # array 4 is real but log channels shouldn't be in sort
        self.assertFalse('Array_t_004' in self.ph5API_object.Sort_t)

        # get table entry on start time and array
        sort_t = self.ph5API_object.get_sort_t(
            1550849943,
            'Array_t_009')
        self.assertTrue(sort_t)
        self.assertEqual(1, len(sort_t))

        # entry doesn't exist
        sort_t = self.ph5API_object.get_sort_t(
            99999,
            'Array_t_009')
        self.assertFalse(sort_t)

        sort_t = self.ph5API_object.get_sort_t(
            99999,
            'Array_t_999')
        self.assertFalse(sort_t)

    def test_read_t(self):
        """
        tests reading of table and outputting kef
        """
        # experiment tableF
        table = self.ph5API_object.read_t("Experiment_t")
        self.assertIn('/Experiment_g/Experiment_t', table)
        self.assertIn('experiment_id_s = 99-999', table)
        self.assertIn('net_code_s = AA', table)

        # Array tables
        table = self.ph5API_object.read_t("Array_t", 1)
        self.assertIn('\'id_s\': \'500\'', table)
        table = self.ph5API_object.read_t("Array_t", 8)
        self.assertIn('\'seed_station_name_s\': \'8001\'', table)

        # Response table
        table = self.ph5API_object.read_t("Response_t")
        self.assertIn('/Experiment_g/Responses_g/Response_t', table)
        self.assertIn('/Experiment_g/Responses_g/cmg3t', table)

        # Receiver table
        table = self.ph5API_object.read_t("Receiver_t")
        self.assertIn('/Experiment_g/Receivers_g/Receiver_t', table)
        self.assertIn('orientation/azimuth/value_f', table)

        # Index table
        table = self.ph5API_object.read_t("Index_t")
        self.assertIn('/Experiment_g/Receivers_g/Index_t', table)
        self.assertIn('./miniPH5_00001.ph5', table)

        # Das table
        table = self.ph5API_object.read_t("Das_t", '12183')
        self.assertIn('/Experiment_g/Receivers_g/Das_t_12183/Das_t', table)
        self.assertNotIn('/Experiment_g/Receivers_g/Das_g_9EEF/Das_t', table)
        self.assertIn('raw_file_name_s = I2183RAW.TRD', table)
        # a key error should be raised because there is no das XXX
        self.assertRaises(KeyError, self.ph5API_object.read_t, "Das_t", "XXX")

        # Time table
        table = self.ph5API_object.read_t("Time_t")
        self.assertIn('/Experiment_g/Receivers_g/Time_t', table)
        self.assertIn('das/serial_number_s = 12183', table)

        # Sort table
        table = self.ph5API_object.read_t("Sort_t")
        self.assertIn('/Experiment_t/Sorts_g/Sort_t', table)

        # Event table
        table = self.ph5API_object.read_t("Event_t")
        self.assertIn('/Experiment_g/Sorts_g/Event_t_001', table)

        # Offset table
        table = self.ph5API_object.read_t("Offset_t")
        self.assertIn('Experiment_g/Sorts_g/Offset_t_001_001', table)

        # table that doesnt exist
        table = self.ph5API_object.read_t("Random_t")
        self.assertFalse(table)

    def test_textural_cut(self):
        """
        tests cutting of text data from arrays
        """
        # try  das that doesn't exist
        traces = self.ph5API_object.textural_cut('0407',
                                                 1545088203,
                                                 1547489525,
                                                 -2,
                                                 None)
        self.assertFalse(traces)

        # no das_t
        traces = self.ph5API_object.textural_cut('5553',
                                                 1545088203,
                                                 1547489525,
                                                 -2,
                                                 None)
        # traces exist
        self.assertTrue(traces)
        # 1 trace
        self.assertEqual(1, len(traces))
        # 0 sample rate
        self.assertEqual(0, traces[0].sample_rate)
        # ttype is '|S1' (one character per sample)
        self.assertEqual('|S1', traces[0].ttype)
        # turn data into string to more easily read it
        str1 = ''.join(traces[0].data)
        self.assertIn('TIME JUMP OF  3.000400 SECONDS', str1)

        # with das_t
        self.ph5API_object.read_das_t('5553')
        das_t = self.ph5API_object.Das_t['5553']['rows']
        traces = self.ph5API_object.textural_cut('5553',
                                                 1545088203,
                                                 1547489525,
                                                 -2,
                                                 das_t)
        # traces exist
        self.assertTrue(traces)
        # 1 trace
        self.assertEqual(1, len(traces))
        # 0 sample rate
        self.assertEqual(0, traces[0].sample_rate)
        # ttype is '|S1' (one character per sample)
        self.assertEqual('|S1', traces[0].ttype)
        # turn data into string to more easily read it
        str1 = ''.join(traces[0].data)
        self.assertIn('TIME JUMP OF  3.000400 SECONDS', str1)

        # try channel with data instead of text
        traces = self.ph5API_object.textural_cut('5553',
                                                 0,
                                                 9547489525,
                                                 1,
                                                 None)
        self.assertFalse(traces)

    def test_cut(self):
        # try cutting das that doesn't exist
        # should return a single trace object with no data
        traces = self.ph5API_object.cut('9999',
                                        0,
                                        1599999999,
                                        1,
                                        250,
                                        True,
                                        das_t=None)
        self.assertTrue(1, len(traces))
        self.assertFalse(traces[0].data)

        # read actual data no time correction
        traces = self.ph5API_object.cut('12183',
                                        1550849943,
                                        1550850189,
                                        1,
                                        500,
                                        False,
                                        das_t=None)

        # 9 traces with NO time corrections
        # all same sample rate and ttype
        self.assertTrue(9, len(traces))
        for trace in traces:
            self.assertEqual(0.0, trace.time_correction_ms)
            self.assertEqual(500, trace.sample_rate)
            self.assertEqual('int', trace.ttype)
        # check start times match
        self.assertEqual(1550849943.00,
                         traces[0].start_time.epoch(fepoch=True))
        # check a few samples
        self.assertEqual(-1412641,
                         traces[0].data[0])
        self.assertEqual(-1180944,
                         traces[0].data[872])
        self.assertEqual(-1371008,
                         traces[0].data[-1])
        self.assertEqual(1550850123.00,
                         traces[6].start_time.epoch(fepoch=True))
        self.assertEqual(-1407159,
                         traces[6].data[0])
        self.assertEqual(-1185688,
                         traces[6].data[872])
        self.assertEqual(-1366398,
                         traces[6].data[-1])

        # read actual data no time correction
        # give das_t this time
        self.ph5API_object.read_das_t('12183')
        das_t = self.ph5API_object.Das_t['12183']['rows']
        traces = self.ph5API_object.cut('12183',
                                        1550849943,
                                        1550850189,
                                        1,
                                        500,
                                        False,
                                        das_t=das_t)

        # 9 traces with NO time corrections
        # all same sample rate and ttype
        self.assertTrue(9, len(traces))
        for trace in traces:
            self.assertEqual(0.0, trace.time_correction_ms)
            self.assertEqual(500, trace.sample_rate)
            self.assertEqual('int', trace.ttype)

        # Check for a exception with a cut in the gap
        throwexception = False
        try:
            traces = self.ph5API_object.cut('12183',
                                            1550849950,
                                            1550849974,
                                            1,
                                            None,
                                            False,
                                            das_t=das_t)

        except Exception:
            throwexception = True
        self.assertTrue(throwexception, 'Throw None type exception')

        # check nodes since they don't star on even seconds\
        # read actual data no time correction
        traces = self.ph5API_object.cut('3X500',
                                        1502294405.38,
                                        1502294410.38,
                                        3,
                                        500,
                                        False,
                                        das_t=None)
        self.assertEqual(1502294405.38,
                         traces[0].start_time.epoch(fepoch=True))
        # 1 traces with NO time corrections
        # all same sample rate and ttype
        self.assertTrue(1, len(traces))
        for trace in traces:
            self.assertEqual(0.0, trace.time_correction_ms)
            self.assertEqual(500, trace.sample_rate)
            self.assertEqual('int', trace.ttype)

        # 2500 samples
        self.assertEqual(2500, traces[0].nsamples)

        # should start half way thorugh data array
        # check a few samples
        # should match sample 2500 in array 005
        self.assertEqual(1317166976,
                         traces[0].data[0])
        # should match sample 4999 in array 005
        self.assertEqual(-122580344,
                         traces[0].data[-1])

    def test_get_extent(self):
        # test das that exists
        earliest, latest = self.ph5API_object.get_extent(
            '9EEF',
            1,
            100,
            start=None,
            end=None)

        self.assertEqual(1463568480, earliest)
        self.assertEqual(1463568517.88, latest)

        # test das that doesn't exist
        earliest, latest = self.ph5API_object.get_extent(
            'xxxx',
            1,
            900,
            start=None,
            end=None)
        self.assertFalse(earliest)
        self.assertFalse(latest)

        # test with multiple das table entries
        earliest, latest = self.ph5API_object.get_extent(
            '3X500',
            2,
            500,
            start=None,
            end=None)

        self.assertEqual(1502294400.38, earliest)
        self.assertEqual(1502294460.38, latest)

        # test giving start time and end time
        earliest, latest = self.ph5API_object.get_extent(
            '3X500',
            1,
            500,
            start=1502294405.38,
            end=1502294459.00)

        self.assertEqual(1502294400.38, earliest)
        self.assertEqual(1502294460.38, latest)

        # test giving start time only
        self.assertRaises(ValueError,
                          self.ph5API_object.get_extent,
                          '3X500',
                          1,
                          500,
                          start=1502294405.38,
                          end=None)
        # test giving end time only
        self.assertRaises(ValueError,
                          self.ph5API_object.get_extent,
                          '3X500',
                          1,
                          500,
                          start=None,
                          end=1502294460.38)

        # test LOG
        earliest, latest = self.ph5API_object.get_extent(
            '5553',
            -2,
            0,
            start=1545088205,
            end=1545088205)

        self.assertEqual(1545088205, earliest)
        self.assertEqual(1545088205, latest)

        # test LOG no times
        earliest, latest = self.ph5API_object.get_extent(
            '5553',
            -2,
            0,
            start=None,
            end=None)

        self.assertEqual(1545088205, earliest)
        self.assertEqual(1545088205, latest)

        # test das with same chan # and various sample rates
        earliest, latest = self.ph5API_object.get_extent(
            '5553',
            1,
            100,
            start=None,
            end=None)

        self.assertEqual(1545085230.681998, earliest)
        self.assertEqual(1545085240.691998, latest)
        earliest, latest = self.ph5API_object.get_extent(
            '5553',
            1,
            200,
            start=None,
            end=None)

        self.assertEqual(1545085230.917, earliest)
        self.assertAlmostEqual(1545085240.922, latest, 5)

    def test_get_availability(self):
        # test das that doesn't exist
        times = self.ph5API_object.get_availability(
            '12345',
            10000,
            99)
        self.assertFalse(times)

        # simple with gaps
        times = self.ph5API_object.get_availability(
            '12183',
            500,
            1)
        self.assertEqual(9, len(times))
        self.assertEqual((500, 1550849943, 1550849949), times[0])
        self.assertEqual((500, 1550850033, 1550850034), times[3])
        self.assertEqual((500, 1550850183, 1550850189), times[8])

        # no gaps single sample rate per ch
        # multiple windows
        times = self.ph5API_object.get_availability(
            '3X500',
            500,
            3)
        self.assertEqual(1, len(times))
        self.assertEqual((500, 1502294400.38, 1502294460.38), times[0])

        # no gaps single sample rate per ch
        # single window
        times = self.ph5API_object.get_availability(
            '9EEF',
            100,
            2)
        self.assertEqual(1, len(times))
        self.assertEqual((100, 1463568480, 1463568517.88), times[0])

        # no gaps multiple sample rate per ch
        # single window
        times = self.ph5API_object.get_availability(
            '5553',
            200,
            1)
        self.assertEqual(1, len(times))
        self.assertEqual((200.0, 1545085230.917, 1545085240.9220002),
                         times[0])
        times = self.ph5API_object.get_availability(
            '5553',
            100,
            1)
        self.assertEqual(1, len(times))
        self.assertEqual((100.0, 1545085230.681998, 1545085240.691998),
                         times[0])

    def test_channels(self):
        # add read_array_t() bc commented it out in channels()
        self.ph5API_object.read_array_t('Array_t_001')
        # should give 3 channels
        chans = self.ph5API_object.channels(
            'Array_t_001',
            '500')
        self.assertEqual(3, len(chans))
        self.assertEqual([1, 2, 3], chans)

        self.ph5API_object.read_array_t('Array_t_004')
        # should give 1 channels
        chans = self.ph5API_object.channels(
            'Array_t_004',
            '0407')
        self.assertEqual(1, len(chans))
        self.assertEqual([-2], chans)

        # should give 0 channels
        chans = self.ph5API_object.channels(
            'Array_t_099',
            '1234')
        self.assertEqual(0, len(chans))
        self.assertFalse(chans)

    def test_trace_padding(self):
        """
        test padding of traces
        """
        # get all traces from station 9001
        # pad them to be the same length

        traces = self.ph5API_object.cut(
            '12183',
            1550849840,
            1550851189,
            chan=1,
            sample_rate=500,
            apply_time_correction=True,
            das_t=None)
        self.assertEqual(9, len(traces))
        # check that trace lengths vary
        sample_total = 0
        for x in traces:
            sample_total = sample_total + len(x.data)

        start_time = traces[0].start_time
        end_time = traces[-1].start_time + (
                traces[-1].nsamples/traces[-1].sample_rate)
        # now we should have a single trace with gaps padded
        # with the mean
        traces = ph5api.pad_traces(traces)
        self.assertTrue(traces)
        self.assertTrue(sample_total, len(traces.data))
        self.assertTrue(start_time, traces.start_time)
        self.assertTrue(end_time, traces.start_time+(
                traces.nsamples/traces.sample_rate))
        self.assertTrue(-119984, traces.padding)

    def test_mix_ins(self):
        """
        test the added mjix in at end of ph5api that
        aren't used within api itself
        """
        # true case
        result = ph5api.is_in(
            0,
            10000,
            5,
            1000)
        self.assertTrue(result)

        # false
        result = ph5api.is_in(
            99999,
            10000,
            5,
            1000)
        self.assertFalse(result)

        # get float epoch
        fepoch = ph5api.fepoch(1000000, 9555)
        self.assertEqual(1000000.009555, fepoch)
        fepoch = ph5api.fepoch(1978346, 100000000)
        self.assertEqual(1978446, fepoch)

        # filter a das
        self.ph5API_object.read_das_t('5553')
        das_t = ph5api.filter_das_t(
            self.ph5API_object.Das_t['5553']['rows'],
            1)
        self.assertEqual(2, len(das_t))
        das_t = ph5api.filter_das_t(
            self.ph5API_object.Das_t['5553']['rows'],
            -2)
        self.assertEqual(1, len(das_t))
        das_t = ph5api.filter_das_t(
            self.ph5API_object.Das_t['5553']['rows'],
            -9)
        self.assertEqual(0, len(das_t))

    def test_close_ph5(self):
        self.ph5API_object.clear()
        self.ph5API_object.close()
        self.assertIsNone(self.ph5API_object.ph5)


class TestPH5API_srm_query_das_t(TempDirTestCase, LogTestCase):
    def tearDown(self):
        self.ph5_object.ph5close()
        super(TestPH5API_srm_query_das_t, self).tearDown()

    def test_query_das_t_srm0(self):
        # sample_rate_multiplier_i=0 => query_das_t raise error

        ph5path = os.path.join(
            self.home,
            'ph5/test_data/ph5/sampleratemultiplier0/array_das')
        self.ph5_object = ph5api.PH5(path=ph5path, nickname='master.ph5')

        with self.assertRaises(ph5api.APIError) as context:
            self.ph5_object.query_das_t(
                '1X1111', 1, 1562198400, 1562284800, 1000)
            self.assertEqual(context.exception.errno, -1)
        self.assertEqual(
            context.exception.msg,
            ('Das_t_1X1111 has sample_rate_multiplier_i with value 0. '
             'Please run fix_srm to fix sample_rate_multiplier_i for PH5 data.'
             ))

    def test_query_das_t_nosrm(self):
        # sample_rate_multiplier_i missing => query_das_t raise error
        nosrmpath = os.path.join(self.home,
                                 'ph5/test_data/ph5_no_srm/array_das')
        self.ph5_object = ph5api.PH5(path=nosrmpath, nickname='master.ph5')

        with self.assertRaises(ph5api.APIError) as context:
            self.ph5_object.query_das_t(
                '1X1111', 1, 1562198400, 1562284800, 1000)
            self.assertEqual(context.exception.errno, -1)
        self.assertEqual(
            context.exception.msg,
            ('Das_t_1X1111 has sample_rate_multiplier_i missing. '
             'Please run fix_srm to fix sample_rate_multiplier_i for PH5 data.'
             ))


class TestPH5API_precision(TempDirTestCase, LogTestCase):
    def setUp(self):
        super(TestPH5API_precision, self).setUp()
        testargs = ['initialize_ph5', '-n', 'master.ph5']
        with patch.object(sys, 'argv', testargs):
            initialize_ph5.main()

        segd_file = os.path.join(
            self.home, "ph5/test_data/segd/smartsolo/453005513.2.2021.05.08."
                       "20.06.00.000.E.segd")
        testargs = ['segdtoph5', '-n', 'master', '-r', segd_file]
        with patch.object(sys, 'argv', testargs):
            segd2ph5.main()

        self.ph5obj = ph5api.PH5(path=self.tmpdir,
                                 nickname='master.ph5')

    def tearDown(self):
        self.ph5obj.ph5close()
        super(TestPH5API_precision, self).tearDown()

    def test_cut(self):
        traces = self.ph5obj.cut(das='1X1',
                                 start_fepoch=1620504374.0,
                                 stop_fepoch=1620504375.0,
                                 chan=2,
                                 sample_rate=250.0)

        self.assertEqual(len(traces), 2)
        # before fixed: 237
        self.assertEqual(traces[1].nsamples, 236)


class TestPH5APICutTimeStartInMiddleOfSample(LogTestCase):
    """
    This test to make sure the traces return will be at or after the cut
    """
    def setUp(self):
        super(TestPH5APICutTimeStartInMiddleOfSample, self).setUp()
        self.home = os.getcwd()
        self.ph5API_object = ph5api.PH5(
            path=os.path.join(
                self.home, 'ph5/test_data/ph5_cut_start_in_middle_of_sample'),
            nickname='master.ph5')

    def tearDown(self):
        self.ph5API_object.close()
        super(TestPH5APICutTimeStartInMiddleOfSample, self).tearDown()

    def test_cut(self):
        cut_start_epoch = 1508630400.0
        cut_end_epoch = 1508716799.0
        das = self.ph5API_object.query_das_t(
            das='A123', chan=1, sample_rate=100, sample_rate_multiplier=1,
            start_epoch=cut_start_epoch, stop_epoch=cut_end_epoch
        )
        das = [x for x in das]
        traces = self.ph5API_object.cut(
            das='A123', chan=1, sample_rate=100, das_t=das,
            start_fepoch=cut_start_epoch, stop_fepoch=cut_end_epoch,
            apply_time_correction=True
        )

        trace_start_epoch = traces[0].start_time.epoch(fepoch=True)
        # make sure trace start at or after cut start
        self.assertGreaterEqual(trace_start_epoch, cut_start_epoch)


if __name__ == "__main__":
    unittest.main()
